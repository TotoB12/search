I am working on web app that will act like a simply search engine, where users can enter a search term or question, and get an AI generated answer in seconds. Here is the full project:

public\index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SearchT</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1 id="logo">SearchT</h1>
    <form id="search-form">
        <div class="search-container">
            <button type="submit" id="search-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
            </button>
            <input type="text" id="search-input" placeholder="What are you looking for?" required>
        </div>
    </form>
    <div id="loading" style="display: none;">Loading...</div>
    <div class="answerContainer">
        <div id="answer" style="display: none;"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.8/dist/purify.min.js"></script>
    <script src="script.js"></script>
</body>
</html>
```

public\script.js
```javascript
document.addEventListener('DOMContentLoaded', function () {
    const highlightExtension = {
        name: 'highlight',
        level: 'inline',
        start(src) { return src.indexOf('{{'); },
        tokenizer(src, tokens) {
            const rule = /^{{(?!{)([\s\S]+?[^}])}}(?!})/;
            const match = rule.exec(src);
            if (match) {
                return {
                    type: 'highlight',
                    raw: match[0],
                    text: match[1],
                };
            }
        },
        renderer(token) {
            return '<span class="highlight">' + token.text + '</span>';
        }
    };

    marked.use({ extensions: [highlightExtension] });


    const searchForm = document.getElementById('search-form');
    const searchInput = document.getElementById('search-input');
    const loadingDiv = document.getElementById('loading');
    const answerDiv = document.getElementById('answer');

    searchForm.addEventListener('submit', function (e) {
        e.preventDefault();
        const query = searchInput.value.trim();
        if (query) {
            activateSearchLayout();
            submitSearch(query);
        }
    });

    function activateSearchLayout() {
        document.body.classList.add('search-active');
    }

    async function submitSearch(query) {
        loadingDiv.style.display = 'block';
        answerDiv.style.display = 'none';

        try {
            const response = await fetch('/api/search', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query }),
            });

            if (!response.ok) {
                throw new Error('Network response was not ok');
            }

            const data = await response.json();
            pollForResult(data.jobId);
        } catch (error) {
            loadingDiv.style.display = 'none';
            answerDiv.style.display = 'block';
            answerDiv.innerText = `Error: ${error.message}`;
        }
    }

    async function pollForResult(jobId) {
        try {
            const response = await fetch(`/api/result/${jobId}`);
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }

            const data = await response.json();

            if (data.status === 'completed') {
                console.log(data.answer);
                loadingDiv.style.display = 'none';
                answerDiv.style.display = 'block';
                answerDiv.innerHTML = DOMPurify.sanitize(marked.parse(data.answer));
            } else if (data.status === 'error') {
                loadingDiv.style.display = 'none';
                answerDiv.style.display = 'block';
                answerDiv.innerText = `Error: ${data.error}`;
            } else {
                setTimeout(() => pollForResult(jobId), 100);
            }
        } catch (error) {
            loadingDiv.style.display = 'none';
            answerDiv.style.display = 'block';
            answerDiv.innerText = `Error: ${error.message}`;
        }
    }
});

```

public\style.css
```css
@font-face {
    font-family: "Poly Sans";
    src: url('fonts/PolySansNeutral.ttf') format('truetype');
}

@font-face {
    font-family: "Poly Sans Bulky";
    src: url('fonts/PolySansBulky.ttf') format('truetype');
}

@font-face {
    font-family: "Poly Sans Slim";
    src: url('fonts/PolySansSlim.ttf') format('truetype');
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: "Poly Sans", Arial, sans-serif;
    background-color: #ffffff;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    transition: padding-top 0.5s ease;
}

#logo {
    font-family: "Poly Sans Bulky", Arial, sans-serif;
    font-size: 4rem;
    color: #333;
    /* transition: all 0.5s ease; */
}

#search-form {
    width: 100%;
    max-width: 800px;
    padding: 2rem;
    text-align: center;
    transition: all 0.5s ease;
}

.search-container {
    display: flex;
    background-color: #efefef;
    border-radius: 50px;
    padding: 0.5rem;
    margin: 0 auto;
    transition: all 0.5s ease;
}

::placeholder {
    color: #8b8b8b;
}

#search-input {
    flex-grow: 1;
    border: none;
    outline: none;
    font-family: "Poly Sans", Arial, sans-serif;
    font-size: 1.2rem;
    padding: 0.5rem;
    background: transparent;
}

#search-button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
}

#search-button svg {
    width: 24px;
    height: 24px;
    color: #333;
    transition: color 0.3s ease;
}

#search-button:hover svg {
    color: #007bff;
}

#loading {
    margin-top: 2rem;
    font-size: 1.5rem;
    color: #333;
    transition: display 0.5s ease;
}

#answer {
    text-align: left;
    padding: 1rem;
    font-size: 1.1rem;
}

#answer h1,
#answer h2,
#answer h3 {
    font-family: "Poly Sans Bulky", Arial, sans-serif;
    margin-top: 1.5rem;
    margin-bottom: 0.5rem;
}

#answer p {
    margin-bottom: 1rem;
    line-height: 1.6;
}

#answer ul,
#answer ol {
    margin-bottom: 1rem;
    padding-left: 1.5rem;
}

#answer code {
    background-color: #f5f5f5;
    padding: 0.2rem 0.4rem;
    border-radius: 4px;
    font-family: "Poly Sans Slim", monospace;
}

#answer pre {
    background-color: #f5f5f5;
    padding: 1rem;
    margin-bottom: 1rem;
    border-radius: 4px;
    overflow-x: auto;
}

#answer blockquote {
    border-left: 4px solid #ccc;
    padding-left: 1rem;
    color: #666;
    margin-bottom: 1rem;
}

#answer a {
    color: #007bff;
    text-decoration: none;
}

#answer a:hover {
    text-decoration: underline;
}

.highlight {
    background-color: #c4c4c4;
    padding: 0.2em;
    border-radius: 4px;
}

.answerContainer {
    width: 100%;
    max-width: 800px;
    padding: 2rem;
    display: flex;
    flex-direction: column;
}

body.search-active {
    padding-top: 100px;
    justify-content: flex-start;
}

body.search-active #logo {
    font-size: 2rem;
    position: fixed;
    top: 15px;
    left: 20px;
    margin: 0;
}

body.search-active #search-form {
    position: fixed;
    top: 0;
    width: 100%;
    padding: 10px 0;
}

body.search-active .search-container {
    max-width: 600px;
    width: 100%;
    margin: 0 auto;
}

@media (max-width: 600px) {
    #logo {
        font-size: 3rem;
    }

    .search-container {
        width: 100%;
    }

    body.search-active .search-container {
        width: 90%;
    }
}
```

server.js
```javascript
const express = require('express');
const path = require('path');
const axios = require('axios');
const cheerio = require('cheerio');
require('dotenv').config();
const GoogleGenerativeAI = require("@google/generative-ai").GoogleGenerativeAI;
const { HarmBlockThreshold, HarmCategory } = require("@google/generative-ai");
const pLimit = require('p-limit');

const app = express();
const PORT = process.env.PORT || 8000;

app.use(express.static(path.join(__dirname, 'public')));
app.use(express.json());

const jobQueue = new Map();

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.post('/api/search', (req, res) => {
    const query = req.body.query;
    if (!query) {
        res.status(400).json({ error: 'No query provided' });
        return;
    }

    const jobId = Date.now().toString();
    jobQueue.set(jobId, { status: 'pending', query });

    processJob(jobId);

    res.json({ jobId });
});

app.get('/api/result/:jobId', (req, res) => {
    const jobId = req.params.jobId;
    const job = jobQueue.get(jobId);

    if (!job) {
        res.status(404).json({ error: 'Job not found' });
    } else {
        res.json(job);
    }
});

const genAI = new GoogleGenerativeAI(process.env.AI_STUDIO_KEY);
const safetySettings = [
    {
        category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_HARASSMENT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
];
const model = genAI.getGenerativeModel({
    model: "gemini-1.5-flash",
    generationConfig: {
        temperature: 0.0
    },
    safetySettings: safetySettings,
    // systemInstruction: ""
});

async function processJob(jobId) {
    const job = jobQueue.get(jobId);

    try {
        const searchResults = await searchInternet(job.query);
        const prompt = `You are a helpful search companion and assistant. Your purpose is to generate relevant and concise summaries to answer/respond the user's query.
The user's query is:

\`\`\`
${job.query}
\`\`\`

Your response should be easy to read and understand, and be presented in a helpful and informative manner. Keep in mind that it should be relatively short. Make sure to provide accurate and relevant information.

You should format it to be aerated and stuctured, and not be an ugly paragraph. You may use Markdown to format your response.
If your response contains a group of words that can be used as a direct answer to the user's query, have those words be contained inside two couple of cury brackets, like this: {{this is part of a sentence that will be highlighted}}.

Nerver appologize for not being able to find an answer. Always answer something.

You have online results to assist you in your response. If you use any of the content from these results, provide a citation to the original source using its index number. You can use the following format to cite a result: {{{number}}}
For example, to cite the first result, use {{{0}}}
To cite the second and fourth results, use {{{1,3}}}

Web results:

\`\`\`
${JSON.stringify(searchResults, null, 2)}
\`\`\`
`;

        const aiResult = await aiResponse(prompt);
        jobQueue.set(jobId, { status: 'completed', answer: aiResult });
    } catch (error) {
        console.error(error);
        jobQueue.set(jobId, { status: 'error', error: 'Internal Server Error' });
    }
}

async function searchInternet(query) {
    try {
        console.log(`Debug: Searching DuckDuckGo for '${query}'`);

        const headers = {
            'User-Agent':
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
                '(KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        };

        const url = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`;
        const response = await axios.get(url, { headers });

        if (response.status !== 200) {
            console.log(`Error: HTTP error ${response.status}`);
            return { error: `HTTP error ${response.status}` };
        }

        const $ = cheerio.load(response.data);
        let results = [];
        $('a.result__a').each((i, elem) => {
            const href = $(elem).attr('href');
            if (href) {
                results.push(href);
            }
        });

        results = results
            .filter(url => !url.startsWith("https://duckduckgo.com"))
            .slice(0, 4);
        console.log(`Found ${results.length} results:`, results);

        const maxCharacters = 2000000;

        const limit = pLimit(4);

        const fetchPagePromises = results.map((resultUrl, index) => limit(async () => {
            console.log(`Fetching result page: ${resultUrl}`);
            try {
                const pageResponse = await axios.get(resultUrl, {
                    headers,
                    maxRedirects: 2,
                    timeout: 1200,
                    validateStatus: function (status) {
                        return status >= 200 && status < 400;
                    },
                });

                const $page = cheerio.load(pageResponse.data);

                $page('script, style').remove();

                const pageText = $page('body').text()
                    .replace(/\s+/g, ' ')
                    .trim();

                return {
                    index: index,
                    resultUrl: resultUrl,
                    content: pageText,
                };
            } catch (error) {
                console.log(`Error: Failed to fetch page ${resultUrl}, ${error.message}`);
                return null;
            }
        }));

        const fetchedResults = await Promise.all(fetchPagePromises);

        let outputResults = [];
        let totalContentLength = 0;

        for (let result of fetchedResults) {
            if (result && totalContentLength < maxCharacters) {
                let contentToAdd;
                if (totalContentLength + result.content.length > maxCharacters) {
                    contentToAdd = result.content.slice(0, maxCharacters - totalContentLength);
                    totalContentLength = maxCharacters;
                } else {
                    contentToAdd = result.content;
                    totalContentLength += contentToAdd.length;
                }

                outputResults.push({
                    index: result.index,
                    resultUrl: result.resultUrl,
                    content: contentToAdd,
                });

                if (totalContentLength >= maxCharacters) {
                    break;
                }
            }
        }

        return outputResults;

    } catch (error) {
        console.error(`Error: ${error.message}`);
        return { error: error.message };
    }
}

async function aiResponse(prompt) {
    try {
        const result = await model.generateContent(prompt);
        return result.response.text();
    } catch (error) {
        console.log(error);
        return { error: error };
    }
}

app.listen(PORT, '0.0.0.0', () => {
    console.log(`Server is running on port ${PORT}`);
});

```

This all works great, but I want to add new features. I want the server to return the response inside of a JSON object. This object should also have an element containing the used URLs, with their index. I want you to implement this. Make sure to modify the client script to use the response from the object.