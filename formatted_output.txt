I am working on web app that will act like a simply search engine, where users can enter a search term or question, and get an AI generated answer in seconds. Here is the full project:

public\index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simple AI Search</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Welcome to Simple AI Search</h1>
        <div id="search-container">
            <form id="search-form">
                <input type="text" id="search-input" placeholder="Enter your search term or question..." required>
                <button type="submit">Search</button>
            </form>
        </div>
        <div id="loading" style="display: none;">Loading...</div>
        <div id="answer" style="display: none;"></div>
    </div>
    <script src="script.js"></script>
</body>
</html>
```

public\script.js
```javascript
document.addEventListener('DOMContentLoaded', function() {
    const searchForm = document.getElementById('search-form');
    const searchInput = document.getElementById('search-input');
    const loadingDiv = document.getElementById('loading');
    const answerDiv = document.getElementById('answer');

    searchForm.addEventListener('submit', function(e) {
        e.preventDefault();
        const query = searchInput.value.trim();
        if (query) {
            submitSearch(query);
        }
    });

    async function submitSearch(query) {
        loadingDiv.style.display = 'block';
        answerDiv.style.display = 'none';

        try {
            const response = await fetch('/api/search', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query }),
            });

            if (!response.ok) {
                throw new Error('Network response was not ok');
            }

            const data = await response.json();
            pollForResult(data.jobId);
        } catch (error) {
            loadingDiv.style.display = 'none';
            answerDiv.style.display = 'block';
            answerDiv.innerText = `Error: ${error.message}`;
        }
    }

    async function pollForResult(jobId) {
        try {
            const response = await fetch(`/api/result/${jobId}`);
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }

            const data = await response.json();

            if (data.status === 'completed') {
                loadingDiv.style.display = 'none';
                answerDiv.style.display = 'block';
                answerDiv.innerText = data.answer;
            } else if (data.status === 'error') {
                loadingDiv.style.display = 'none';
                answerDiv.style.display = 'block';
                answerDiv.innerText = `Error: ${data.error}`;
            } else {
                setTimeout(() => pollForResult(jobId), 100);
            }
        } catch (error) {
            loadingDiv.style.display = 'none';
            answerDiv.style.display = 'block';
            answerDiv.innerText = `Error: ${error.message}`;
        }
    }
});
```

public\style.css
```css
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background-color: #f0f0f0;
}

.container {
    text-align: center;
    background-color: white;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    max-width: 600px;
    width: 100%;
}

h1 {
    margin-bottom: 1.5rem;
    color: #333;
}

#search-container {
    margin-bottom: 1.5rem;
}

#search-form {
    display: flex;
    gap: 0.5rem;
}

#search-input {
    flex-grow: 1;
    padding: 0.5rem;
    font-size: 1rem;
    border: 1px solid #ccc;
    border-radius: 4px;
}

button {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
}

button:hover {
    background-color: #0056b3;
}

#loading {
    font-size: 1.2rem;
    color: #666;
    margin-top: 1rem;
}

#answer {
    text-align: left;
    margin-top: 1rem;
    font-size: 1rem;
    line-height: 1.5;
    color: #333;
}
```

server.js
```javascript
const express = require('express');
const path = require('path');
const axios = require('axios');
const cheerio = require('cheerio');
require('dotenv').config();
const GoogleGenerativeAI = require("@google/generative-ai").GoogleGenerativeAI;

const app = express();
const PORT = process.env.PORT || 8000;

app.use(express.static('public'));
app.use(express.json());

const jobQueue = new Map();

app.post('/api/search', (req, res) => {
    const query = req.body.query;
    if (!query) {
        res.status(400).json({ error: 'No query provided' });
        return;
    }

    const jobId = Date.now().toString();
    jobQueue.set(jobId, { status: 'pending', query });

    processJob(jobId);

    res.json({ jobId });
});

app.get('/api/result/:jobId', (req, res) => {
    const jobId = req.params.jobId;
    const job = jobQueue.get(jobId);

    if (!job) {
        res.status(404).json({ error: 'Job not found' });
    } else {
        res.json(job);
    }
});

async function processJob(jobId) {
    const job = jobQueue.get(jobId);
    
    try {
        const searchResults = await searchInternet(job.query);
        const prompt = `You are a helpful search companion and assistant. Your purpose is to generate relevant and concise summaries of the user's query.
The user's query is:

\`\`\`
${job.query}
\`\`\`

You have the following online results to assist you in your answer.
If you use any of the content from these results, please provide a citation to the original source using its index number. You can use the following format to cite a result: {{{number}}}. For example, to cite the first result, use {{{0}}}.

Web results:

\`\`\`
${JSON.stringify(searchResults, null, 2)}
\`\`\`
`;

        const aiResult = await aiResponse(prompt);
        jobQueue.set(jobId, { status: 'completed', answer: aiResult });
    } catch (error) {
        console.error(error);
        jobQueue.set(jobId, { status: 'error', error: 'Internal Server Error' });
    }
}

async function searchInternet(query) {
    try {
        console.log(`Debug: Searching DuckDuckGo for '${query}'`);

        const headers = {
            'User-Agent':
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
                '(KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        };

        const url = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`;
        const response = await axios.get(url, { headers });

        if (response.status !== 200) {
            console.log(`Error: HTTP error ${response.status}`);
            return { error: `HTTP error ${response.status}` };
        }

        const $ = cheerio.load(response.data);
        let results = [];
        $('a.result__a').each((i, elem) => {
            const href = $(elem).attr('href');
            if (href) {
                results.push(href);
            }
        });

        results = results.slice(0, 7);
        console.log(`Found ${results.length} results:`, results);

        let outputResults = [];
        let totalContentLength = 0;
        const maxCharacters = 125000;
        let index = 0;

        for (let resultUrl of results) {
            if (totalContentLength >= maxCharacters) {
                break;
            }

            console.log(`Fetching result page: ${resultUrl}`);
            try {
                const pageResponse = await axios.get(resultUrl, {
                    headers,
                    maxRedirects: 5,
                    validateStatus: function (status) {
                        return status >= 200 && status < 400;
                    },
                });

                const $page = cheerio.load(pageResponse.data);

                $page('script, style').remove();

                const pageText = $page('body').text()
                    .replace(/\s+/g, ' ')
                    .trim();

                let contentToAdd;
                if (totalContentLength + pageText.length > maxCharacters) {
                    contentToAdd = pageText.slice(0, maxCharacters - totalContentLength);
                } else {
                    contentToAdd = pageText;
                }

                totalContentLength += contentToAdd.length;
                outputResults.push({
                    index: index,
                    resultUrl: resultUrl,
                    content: contentToAdd,
                });
                index++;

                if (totalContentLength >= maxCharacters) {
                    break;
                }
            } catch (error) {
                console.log(`Error: Failed to fetch page ${resultUrl}, ${error.message}`);
                continue;
            }
        }

        return outputResults;
    } catch (error) {
        console.error(`Error: ${error.message}`);
        return { error: error.message };
    }
}

async function aiResponse(prompt) {
    try {
        const genAI = new GoogleGenerativeAI(process.env.AI_STUDIO_KEY);
        const model = genAI.getGenerativeModel({
            model: "gemini-1.5-flash",
            generationConfig: {
                temperature: 0
            },
            systemInstruction: ""
        });

        const result = await model.generateContent(prompt);
        return result.response.text();
    } catch (error) {
        console.log(error);
        return { error: error };
    }
}

app.listen(PORT, '0.0.0.0', () => {
    console.log(`Server is running`);
});

```

This all works well, but I want to give it a fresh new look. I want to use these font everywhere:

```css
@font-face {
  font-family: "Poly Sans";
  src: url('fonts/PolySansNeutral.ttf');
  format: ('truetype');
}

@font-face {
  font-family: "Poly Sans Bulky";
  src: url('fonts/PolySansBulky.ttf');
  format: ('truetype');
}

@font-face {
  font-family: "Poly Sans Slim";
  src: url('fonts/PolySansSlim.ttf');
  format: ('truetype');
}
```

I also want to completely redesign the page. I want the page to initially show in large bulky font "SearchT", with a beautiful curved search box underneath. When a search is requested, I want the title and search box to animate and fly away upwards, but the search box should stay within the view, and position itself at the top of the page, like any other search engine's result page (Google, Bing, DuckDuckGo). I have attached an example image of what the home page should look like.