I have the following script for an API server for one of my web apps:

```javascript
const axios = require('axios');
const cheerio = require('cheerio');
const { image_search } = require("duckduckgo-images-api");
const { GoogleGenerativeAI, HarmBlockThreshold, HarmCategory } = require("@google/generative-ai");
const pLimit = require('p-limit');

const genAI = new GoogleGenerativeAI(process.env.AI_STUDIO_KEY);
const safetySettings = [
    {
        category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_HARASSMENT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    }
];
const model = genAI.getGenerativeModel({
    // model: "gemini-1.5-flash",
    model: "gemini-1.5-flash-8b-exp-0924",
    generationConfig: {
        temperature: 0.0,
        maxOutputTokens: 1000,
        topP: 0.4,
        topK: 10,
        presencePenalty: 0,
        frequencyPenalty: 0,
    },
    safetySettings: safetySettings,
});

async function processQuery(socket, query) {
    try {
        console.log('Processing query:', query);
        const { searchResults, webResults } = await searchInternet(query);

        socket.emit('generalResults', { status: 'completed', webResults });

        const prompt = `You are a helpful search companion and assistant. Your purpose is to generate relevant and concise summaries to answer/respond to the user's query.
The user's query is:

\`\`\`
${query}
\`\`\`

Your response should be easy to read and understand, and be presented in a helpful and informative manner. Keep in mind that it should be relatively short. Make sure to provide accurate and relevant information.

You should format it to be aerated and structured, and not be an ugly paragraph. You may use Markdown to format your response. You should always have a short title before your response using ##.
If your response contains a group of words that can be considered a direct response/answer to the user's query, you should highlight it. To highlight a part of text, have it be contained inside two couples of curly brackets, like this: {{this is part of a sentence that will be highlighted}}.

Never apologize for not being able to find an answer. Always answer something.

You have online results to assist you in your response. If you use any of the content from these results, provide a citation to the original source using its index number. You can use the following format to cite a result: {{{number}}}
For example, to cite the first result, use {{{0}}}
To cite the second and fourth results, use {{{1,3}}}

Web results:

\`\`\`
${JSON.stringify(searchResults, null, 2)}
\`\`\`
`;

        const aiResultPromise = aiResponse(prompt);
        const imagesPromise = get_images(query);

        const [aiResult, images] = await Promise.all([aiResultPromise, imagesPromise]);

        const usedUrls = searchResults.map(result => ({
            index: result.index,
            title: result.title,
            favicon: result.favicon,
            url: result.url
        }));

        socket.emit('aiAnswer', { status: 'completed', answer: aiResult, urls: usedUrls, images: images.images });

    } catch (error) {
        console.error('Error in processQuery:', error);
        socket.emit('error', { status: 'error', error: 'Internal Server Error' });
    }
}

// async function searchInternetOld(query) {
//     const endpoint = "https://api.tavily.com/search";
//     const body = {
//         api_key: process.env.TAVILY_KEY,
//         query: query,
//         search_depth: "basic",
//         include_answer: false,
//         include_images: false,
//         include_raw_content: false,
//         max_results: 4,
//         include_domains: [],
//         exclude_domains: [],
//     };

//     try {
//         const response = await axios.post(endpoint, body);
//         if (response.data && response.data.results) {

//             const results = response.data.results.slice(0, 4);
//             const outputResults = results.map((result, index) => ({
//                 index: index,
//                 url: result.url,
//                 content: result.content,
//             }));

//             return outputResults;
//         }
//     } catch (error) {
//         console.error("Error calling Tavily search API:", error);
//         return { error: error.message };
//     }
// }

async function searchInternet(query) {
    try {
        const headers = {
            'User-Agent':
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
                '(KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        };

        const url = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`;
        const response = await axios.get(url, { headers });

        if (response.status !== 200) {
            console.log(`Error: HTTP error ${response.status}`);
            return { error: `HTTP error ${response.status}` };
        }

        const $ = cheerio.load(response.data);

        const webResults = [];
        $('div.result.results_links.results_links_deep.web-result').each((i, elem) => {
            const title = $(elem).find('h2.result__title a.result__a').text().trim();
            const url = $(elem).find('h2.result__title a.result__a').attr('href');
            const description = $(elem).find('a.result__snippet').text().trim();
            const favicon = $(elem).find('img.result__icon__img').attr('src') || '';

            const isAd = $(elem).find('.badge--ad').length > 0;
            if (!isAd) {
                webResults.push({
                    title,
                    url,
                    description,
                    favicon
                });
            }
        });

        const maxCharacters = 2000000;
        const limit = pLimit(4);
        let searchResults = [];
        let totalContentLength = 0;
        let currentIndex = 0;

        const fetchPagePromises = webResults.slice(0, 4).map((result) => limit(async () => {
            const url = result.url;
            try {
                const pageResponse = await axios.get(url, {
                    headers,
                    maxRedirects: 2,
                    timeout: 1200,
                    validateStatus: function (status) {
                        return status >= 200 && status < 400;
                    },
                });

                const $page = cheerio.load(pageResponse.data);
                $page('script, style').remove();
                const pageText = $page('body').text().replace(/\s+/g, ' ').trim();

                let contentToAdd;
                if (totalContentLength + pageText.length > maxCharacters) {
                    contentToAdd = pageText.slice(0, maxCharacters - totalContentLength);
                    totalContentLength = maxCharacters;
                } else {
                    contentToAdd = pageText;
                    totalContentLength += contentToAdd.length;
                }

                searchResults.push({
                    index: currentIndex,
                    title: result.title,
                    favicon: result.favicon,
                    url: url,
                    content: contentToAdd,
                });
                currentIndex++;

            } catch (error) {
                console.log(`Error: Failed to fetch page ${url}, ${error.message}`);
            }
        }));

        await Promise.all(fetchPagePromises);

        return { searchResults, webResults };

    } catch (error) {
        console.error(`Error in searchInternet: ${error.message}`);
        return { error: error.message };
    }
}

async function get_images(query, limit = 10) {
    try {
        const results = await image_search({
            query: query,
            moderate: false,
            iterations: 1,
            retries: 2,
        });
        const images = results.slice(0, limit).map((result) => result.image);
        images.forEach((image, index) => {
            images[index] = `https://api.totob12.com/image/${encodeURIComponent(image)}`;
            // images[index] = `https://wsrv.nl/?url=${encodeURIComponent(image)}`;
        });
        return { images: images };
    } catch (error) {
        console.error(error);
        return { results: null };
    }
}

async function aiResponse(prompt) {
    try {
        const result = await model.generateContent(prompt);
        return result.response.text();
    } catch (error) {
        console.log(error);
        return "## Internal Server Error\n\nAn error occurred processing your query.";
    }
}

module.exports = {
    processQuery
};
```

This works, but I want to ensure that `webResults` is emited to the client as soon as it is available and ready, having it not need to wait for `searchResults` to be composed. I still want only one DuckDuckGo search to happen, to ensure it is as fast as possible.
I want you to fully develop and implement this. Give me the full new search.js file.