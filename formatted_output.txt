I am working on web app that will act like a simply search engine, where users can enter a search term or question, and get an AI generated answer in seconds. Here is the full project:

public\index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SearchT</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1 id="logo">SearchT</h1>
    <form id="search-form">
        <div class="search-container">
            <button type="submit" id="search-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
            </button>
            <input type="text" id="search-input" placeholder="What are you looking for?" required>
        </div>
    </form>
    <div id="loading" style="display: none;">Loading...</div>
    <div class="answerContainer">
        <div id="answer" style="display: none;"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.8/dist/purify.min.js"></script>
    <script src="script.js"></script>
</body>
</html>
```

public\script.js
```javascript
document.addEventListener('DOMContentLoaded', function () {
    const highlightExtension = {
        name: 'highlight',
        level: 'inline',
        start(src) { return src.indexOf('{{'); },
        tokenizer(src, tokens) {
            const rule = /^{{(?!{)([\s\S]+?[^}])}}(?!})/;
            const match = rule.exec(src);
            if (match) {
                return {
                    type: 'highlight',
                    raw: match[0],
                    text: match[1],
                };
            }
        },
        renderer(token) {
            return '<span class="highlight">' + token.text + '</span>';
        }
    };

    marked.use({ extensions: [highlightExtension] });

    function processCitations(text, urls) {
        return text.replace(/\{\{\{(\d+(?:,\d+)*)\}\}\}/g, (match, p1) => {
            const indices = p1.split(',').map(Number);
            const links = indices.map(index => {
                const url = urls.find(u => u.index === index);
                if (url) {
                    return `<a href="${url.url}" target="_blank" rel="noopener noreferrer">${index + 1}</a>`;
                }
                return index + 1;
            });
            return `<sup>[${links.join(',')}]</sup>`;
        });
    }

    const searchForm = document.getElementById('search-form');
    const searchInput = document.getElementById('search-input');
    const loadingDiv = document.getElementById('loading');
    const answerDiv = document.getElementById('answer');

    searchForm.addEventListener('submit', function (e) {
        e.preventDefault();
        const query = searchInput.value.trim();
        if (query) {
            activateSearchLayout();
            submitSearch(query);
        }
    });

    function activateSearchLayout() {
        document.body.classList.add('search-active');
    }

    async function submitSearch(query) {
        loadingDiv.style.display = 'block';
        answerDiv.style.display = 'none';

        try {
            const response = await fetch('https://api.totob12.com/search/search', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query }),
            });

            if (!response.ok) {
                throw new Error('Network response was not ok');
            }

            const data = await response.json();
            pollForResult(data.jobId);
        } catch (error) {
            loadingDiv.style.display = 'none';
            answerDiv.style.display = 'block';
            answerDiv.innerText = `Error: ${error.message}`;
        }
    }

    async function pollForResult(jobId) {
        try {
            const response = await fetch(`https://api.totob12.com/search/result/${jobId}`);
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }

            const data = await response.json();

            if (data.status === 'completed' && !data.answer.error) {
                console.log(data);
                loadingDiv.style.display = 'none';
                answerDiv.style.display = 'block';

                const processedAnswer = processCitations(data.answer, data.urls);
                const parsedHtml = marked.parse(processedAnswer);

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = parsedHtml;

                const firstElement = tempDiv.firstElementChild;
                let insertPosition = 'start';

                if (firstElement && firstElement.tagName === 'H2') {
                    insertPosition = 'afterH2';
                }

                if (data.images && data.images.length > 0) {
                    const imagesToShow = data.images.slice(0, 4);
                    const imageGrid = document.createElement('div');
                    imageGrid.className = 'image-grid';

                    imagesToShow.forEach(imgUrl => {
                        const gridItem = document.createElement('div');
                        gridItem.className = 'image-grid-item';
                        const img = document.createElement('img');
                        img.src = imgUrl + '?p=300';
                        img.alt = 'Related Image';
                        gridItem.appendChild(img);
                        imageGrid.appendChild(gridItem);
                    });

                    if (insertPosition === 'afterH2') {
                        if (firstElement.nextSibling) {
                            tempDiv.insertBefore(imageGrid, firstElement.nextSibling);
                        } else {
                            tempDiv.appendChild(imageGrid);
                        }
                    } else {
                        tempDiv.insertBefore(imageGrid, tempDiv.firstChild);
                    }
                }

                const finalHtml = DOMPurify.sanitize(tempDiv.innerHTML);
                answerDiv.innerHTML = finalHtml;
            } else if (data.status === 'error' || (data.answer && data.answer.error)) {
                loadingDiv.style.display = 'none';
                answerDiv.style.display = 'block';
                console.log(data);
                answerDiv.innerText = `Error: An error occurred while processing the search query`;
            } else {
                setTimeout(() => pollForResult(jobId), 500);
            }
        } catch (error) {
            loadingDiv.style.display = 'none';
            answerDiv.style.display = 'block';
            answerDiv.innerText = `Error: ${error.message}`;
        }
    }
});

```

public\style.css
```css
@font-face {
    font-family: "Poly Sans";
    src: url('fonts/PolySansNeutral.ttf') format('truetype');
}

@font-face {
    font-family: "Poly Sans Bulky";
    src: url('fonts/PolySansBulky.ttf') format('truetype');
}

@font-face {
    font-family: "Poly Sans Slim";
    src: url('fonts/PolySansSlim.ttf') format('truetype');
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: "Poly Sans", Arial, sans-serif;
    background-color: #ffffff;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    transition: padding-top 0.5s ease;
}

#logo {
    font-family: "Poly Sans Bulky", Arial, sans-serif;
    font-size: 4rem;
    color: #333;
    /* transition: all 0.5s ease; */
}

#search-form {
    width: 100%;
    max-width: 800px;
    padding: 2rem;
    text-align: center;
    transition: all 0.5s ease;
}

.search-container {
    display: flex;
    background-color: #efefef;
    border-radius: 50px;
    padding: 0.5rem;
    margin: 0 auto;
    transition: all 0.5s ease;
}

::placeholder {
    color: #8b8b8b;
}

#search-input {
    flex-grow: 1;
    border: none;
    outline: none;
    font-family: "Poly Sans", Arial, sans-serif;
    font-size: 1.2rem;
    padding: 0.5rem;
    background: transparent;
}

#search-button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
}

#search-button svg {
    width: 24px;
    height: 24px;
    color: #333;
    transition: color 0.3s ease;
}

#search-button:hover svg {
    color: #007bff;
}

#loading {
    margin-top: 2rem;
    font-size: 1.5rem;
    color: #333;
    transition: display 0.5s ease;
}

#answer {
    text-align: left;
    padding: 1rem;
    font-size: 1.1rem;
    line-height: 1.6;
}

#answer h1,
#answer h2,
#answer h3 {
    font-family: "Poly Sans Bulky", Arial, sans-serif;
    margin-top: 1.5rem;
    margin-bottom: 1.0rem;
}

#answer p {
    margin-bottom: 1rem;
}

#answer ul,
#answer ol {
    margin-bottom: 1rem;
    padding-left: 1.5rem;
}

#answer code {
    background-color: #f5f5f5;
    padding: 0.2rem 0.4rem;
    border-radius: 4px;
    font-family: "Poly Sans Slim", monospace;
}

#answer pre {
    background-color: #f5f5f5;
    padding: 1rem;
    margin-bottom: 1rem;
    border-radius: 4px;
    overflow-x: auto;
}

#answer blockquote {
    border-left: 4px solid #ccc;
    padding-left: 1rem;
    color: #666;
    margin-bottom: 1rem;
}

#answer a {
    color: #007bff;
    text-decoration: none;
}

#answer a:hover {
    text-decoration: underline;
}

#answer sup {
    font-size: 0.75em;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
    top: -0.5em;
}

#answer sup a {
    color: #007bff;
    text-decoration: none;
    margin: 0 2px;
}

#answer sup a:hover {
    text-decoration: underline;
}

.highlight {
    background-color: #c4c4c4;
    padding: 0.2em;
    border-radius: 4px;
}

.image-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    margin: 1.5rem 0;
}

/* Individual grid items to maintain a square aspect ratio */
.image-grid-item {
    width: 100%;
    padding-top: 100%; /* 1:1 Aspect Ratio */
    position: relative;
    overflow: hidden;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

/* Images within the grid items */
.image-grid-item img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.3s ease;
}

/* Optional: Add a hover effect to images */
.image-grid-item img:hover {
    transform: scale(1.05);
}

.answerContainer {
    width: 100%;
    max-width: 800px;
    padding: 2rem;
    display: flex;
    flex-direction: column;
}

body.search-active {
    padding-top: 100px;
    justify-content: flex-start;
}

body.search-active #logo {
    font-size: 2rem;
    position: fixed;
    top: 15px;
    left: 20px;
    margin: 0;
}

body.search-active #search-form {
    position: fixed;
    top: 0;
    width: 100%;
    padding: 10px 0;
}

body.search-active .search-container {
    max-width: 600px;
    width: 100%;
    margin: 0 auto;
}

@media (max-width: 600px) {
    #logo {
        font-size: 3rem;
    }

    .search-container {
        width: 100%;
    }

    body.search-active .search-container {
        width: 90%;
    }
}

@media (max-width: 800px) {
    .image-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}

@media (max-width: 500px) {
    .image-grid {
        grid-template-columns: 1fr;
    }
}
```

server.js
```javascript
const express = require('express');
const path = require('path');
const axios = require('axios');
const sharp = require('sharp');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 8000;

app.use(express.static(path.join(__dirname, 'public')));
app.use(express.json());

app.get("/image/*", async (req, res) => {
    const imageUrl = decodeURIComponent(req.params[0]);
    const { p } = req.query;

    try {
        const imageResponse = await axios.get(imageUrl, {
            responseType: "stream",
            headers: {
                "User-Agent":
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 " +
                    "(KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0",
            },
        });

        const contentType = imageResponse.headers["content-type"];
        res.set("Content-Type", contentType);

        if (p) {
            const pixels = parseInt(p, 10);

            const transformer = sharp().resize(pixels, pixels, { fit: 'inside' });

            imageResponse.data.pipe(transformer).pipe(res);
        } else {
            imageResponse.data.pipe(res);
        }

    } catch (error) {
        console.error("Failed to retrieve the image:", error);
        res.status(500).send("Failed to retrieve image");
    }
});

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.listen(PORT, '0.0.0.0', () => {
    console.log(`Server is running on port ${PORT}`);
});

```

This all works well, but I want to improve user experience. I want to reduce the amount of time it takes for the user to receive their result. Here is the backend script that runs the API:

server.js
```javascript
const express = require('express');
const axios = require('axios');
const cheerio = require('cheerio');
const { image_search } = require("duckduckgo-images-api");
const { GoogleGenerativeAI, HarmBlockThreshold, HarmCategory } = require("@google/generative-ai");
const pLimit = require('p-limit');

const router = express.Router();

const jobQueue = new Map();

const genAI = new GoogleGenerativeAI(process.env.AI_STUDIO_KEY);
const safetySettings = [
    {
        category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_HARASSMENT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
];
const model = genAI.getGenerativeModel({
    model: "gemini-1.5-flash",
    generationConfig: {
        temperature: 0.0
    },
    safetySettings: safetySettings,
    // systemInstruction: ""
});

async function processJob(jobId) {
    const job = jobQueue.get(jobId);

    try {
        const searchResults = await searchInternet(job.query);
        const prompt = `You are a helpful search companion and assistant. Your purpose is to generate relevant and concise summaries to answer/respond the user's query.
The user's query is:

\`\`\`
${job.query}
\`\`\`

Your response should be easy to read and understand, and be presented in a helpful and informative manner. Keep in mind that it should be relatively short. Make sure to provide accurate and relevant information.

You should format it to be aerated and stuctured, and not be an ugly paragraph. You may use Markdown to format your response. You should always have a short title before your response using ##.
If your response contains a group of words that should be highlighted, have those words be contained inside two couple of cury brackets, like this: {{this is part of a sentence that will be highlighted}}. Don't highlight any entire phrases, just a few words so that the user can quickly see the answer they are looking for.

Never appologize for not being able to find an answer. Always answer something.

You have online results to assist you in your response. If you use any of the content from these results, provide a citation to the original source using its index number. You can use the following format to cite a result: {{{number}}}
For example, to cite the first result, use {{{0}}}
To cite the second and fourth results, use {{{1,3}}}

Web results:

\`\`\`
${JSON.stringify(searchResults, null, 2)}
\`\`\`
`;

        const aiResult = await aiResponse(prompt);

        const usedUrls = searchResults.map(result => ({
            index: result.index,
            url: result.resultUrl
        }));

        const images = await get_images(job.query);

        jobQueue.set(jobId, { status: 'completed', answer: aiResult, urls: usedUrls, images: images.images });
    } catch (error) {
        console.error(error);
        jobQueue.set(jobId, { status: 'error', error: 'Internal Server Error' });
    }
}

async function searchInternet(query) {
    try {
        const headers = {
            'User-Agent':
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
                '(KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        };

        const url = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`;
        const response = await axios.get(url, { headers });

        if (response.status !== 200) {
            console.log(`Error: HTTP error ${response.status}`);
            return { error: `HTTP error ${response.status}` };
        }

        const $ = cheerio.load(response.data);
        let results = [];
        $('a.result__a').each((i, elem) => {
            const href = $(elem).attr('href');
            if (href) {
                results.push(href);
            }
        });

        results = results
            .filter(url => !url.startsWith("https://duckduckgo.com"))
            .slice(0, 4);
        console.log(`Found ${results.length} results for ${query}:`, results);

        const maxCharacters = 2000000;

        const limit = pLimit(4);

        const fetchPagePromises = results.map((resultUrl) => limit(async () => {
            // console.log(`Fetching result page: ${resultUrl}`);
            try {
                const pageResponse = await axios.get(resultUrl, {
                    headers,
                    maxRedirects: 2,
                    timeout: 1200,
                    validateStatus: function (status) {
                        return status >= 200 && status < 400;
                    },
                });

                const $page = cheerio.load(pageResponse.data);

                $page('script, style').remove();

                const pageText = $page('body').text()
                    .replace(/\s+/g, ' ')
                    .trim();

                return {
                    resultUrl: resultUrl,
                    content: pageText,
                };
            } catch (error) {
                console.log(`Error: Failed to fetch page ${resultUrl}, ${error.message}`);
                return null;
            }
        }));

        const fetchedResults = await Promise.all(fetchPagePromises);

        let outputResults = [];
        let totalContentLength = 0;
        let currentIndex = 0;

        for (let result of fetchedResults) {
            if (result && totalContentLength < maxCharacters) {
                let contentToAdd;
                if (totalContentLength + result.content.length > maxCharacters) {
                    contentToAdd = result.content.slice(0, maxCharacters - totalContentLength);
                    totalContentLength = maxCharacters;
                } else {
                    contentToAdd = result.content;
                    totalContentLength += contentToAdd.length;
                }

                outputResults.push({
                    index: currentIndex,
                    resultUrl: result.resultUrl,
                    content: contentToAdd,
                });
                currentIndex++;

                if (totalContentLength >= maxCharacters) {
                    break;
                }
            }
        }

        return outputResults;

    } catch (error) {
        console.error(`Error: ${error.message}`);
        return { error: error.message };
    }
}

async function get_images(query, limit = 10) {
    try {
        const results = await image_search({
            query: query,
            moderate: false,
            iterations: 1,
            retries: 2,
        });
        const images = results.slice(0, limit).map((result) => result.image);
        images.forEach((image, index) => {
            images[index] = `https://api.totob12.com/image/${encodeURIComponent(image)}`;
        });
        return { images: images };
    } catch (error) {
        console.error(error);
        return { results: null };
    }
}

async function aiResponse(prompt) {
    try {
        const result = await model.generateContent(prompt);
        return result.response.text();
    } catch (error) {
        console.log(error);
        return { error: error };
    }
}

router.post('/search', (req, res) => {
    const query = req.body.query;
    if (!query) {
        res.status(400).json({ error: 'No query provided' });
        return;
    }

    const jobId = Date.now().toString();
    jobQueue.set(jobId, { status: 'pending', query });

    processJob(jobId);

    res.json({ jobId });
});

router.get('/result/:jobId', (req, res) => {
    const jobId = req.params.jobId;
    const job = jobQueue.get(jobId);

    if (!job) {
        res.status(404).json({ error: 'Job not found' });
    } else {
        res.json(job);
    }
});

module.exports = router;
```

I think the best way to start would be to have the retrieval of images to happen at the same time as the generation of the AI response (as the images are not needed for that). I want you to fully develop and implement this.